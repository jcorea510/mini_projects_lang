#include <components.hpp>
#include <simulator.hpp>
#include <plotter.hpp>
#include <Eigen/Dense>
#include <iostream>
#include <string>
#include <vector>

int main() {
   	// circuit description (physical node ids include ground 0)
    // nodes: 0 = ground, 1 = v1 node (voltage source +), 2 = node between R1/C1/R2, 3 = node between R2/L1
    int max_node = 3;

    // build components in data form
    std::vector<Component> comps;
    comps.push_back({CompType::VoltageSource, {1,0}, 3.3, "V1"});
    comps.push_back({CompType::Resistor, {1,2}, 1000.0, "R1"});
    comps.push_back({CompType::Capacitor, {2,0}, 0.0000022, "C1"});
    comps.push_back({CompType::Resistor, {2,3}, 1000.0, "R2"});
    comps.push_back({CompType::Inductor, {3,0}, 0.000001, "L1"});

    // Step A: decide unknown layout:
    // unknowns = voltages for node 1..max_node (excluding ground node 0) + one unknown per VoltageSource or Inductor
    // For convenience create node_to_idx map: node -> unknown index (or -1 for ground)
    std::vector<int> node_to_idx(max_node + 1, -1); // vector with max_node + 1 field with value -1
    int idx = 0;
    for(int n = 1; n <= max_node; ++n){
        node_to_idx[n] = idx++;
    }
    int volt_unknowns = idx; // number of node-voltage unknowns (excluding ground)

    // Count extras (voltage sources, inductors)
    int extras_count = 0;
    for(auto &c : comps){
        if(c.type == CompType::VoltageSource || c.type == CompType::Inductor) ++extras_count;
    }
    int total_unknowns = volt_unknowns + extras_count;

    std::cout << "volt unknowns: " << volt_unknowns << " extras: " << extras_count
              << " total unknowns: " << total_unknowns << "\n";

    Eigen::MatrixXd G = Eigen::MatrixXd::Zero(total_unknowns, total_unknowns);
    Eigen::MatrixXd C = Eigen::MatrixXd::Zero(total_unknowns, total_unknowns);
    Eigen::VectorXd b = Eigen::VectorXd::Zero(total_unknowns);

    // extraStartIndex is the index of the first extra variable in the unknown vector
    int extraStartIndex = volt_unknowns;

    // stamp all components
    stamp_all(comps, G, C, b, node_to_idx, extraStartIndex);

    std::cout << "G matrix:\n" << G << "\n\n";
    std::cout << "C matrix:\n" << C << "\n\n";
    std::cout << "b vector:\n" << b.transpose() << "\n\n";
	
	// AC trasient with euler
	Eigen::VectorXd x0 = Eigen::VectorXd::Zero(total_unknowns);
	double dt = 0.1;
	int steps = 20;

	std::vector<Eigen::VectorXd> wave = simulate_backward_euler(G, C, b, x0, dt, steps);

	std::cout << "Time simulation completed.\n";
	std::cout << "Final state:\n" << wave.back().transpose() << "\n\n";

	// Optionally print per-step node voltages:
	for(int i = 0; i < wave.size(); i++){
		double t = i * dt;
		std::cout << "t=" << t
				  << "  v1=" << wave[i][ node_to_idx[1] ]
				  << "  v2=" << wave[i][ node_to_idx[2] ]
				  << "  v3=" << wave[i][ node_to_idx[3] ]
				  << "\n";
	}
	
	std::string path = "./test";
	time_ploter(wave, node_to_idx, dt, path, false);
    return 0;
}
